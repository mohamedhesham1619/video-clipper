package gif

import (
	"clipper/internal/config"
	"clipper/internal/models"
	"clipper/internal/utils"
	"fmt"
	"os/exec"
	"path/filepath"
)

// startVideoDownload starts the video download and doesn't wait for the download to finish, instead it returns running ytdlp command.
func startVideoDownload(downloadProcess *models.DownloadProcess, gifRequest *models.GIFRequest, cfg *config.Config, useYoutubeCookie bool) (ytdlpCmd *exec.Cmd, err error) {

	// Robust ytdlp format selection:
	// 1. Video-only ≥ target height
	// 2. Video-only ≤ target height
	// 3. Combined video and audio ≥ target height
	// 4. Combined video and audio ≤ target height
	formatString := fmt.Sprintf(
		"bestvideo[height>=%[1]v]/bestvideo[height<=%[1]v]/best[height>=%[1]v]/best[height<=%[1]v]",
		gifRequest.Width,
	)

	// The output file name will be in the format: <processID><title>.<ext>
	// <title> and <ext> are generated by yt-dlp.
	// Limit the video title to 60 characters to ensure the full filename (ID + title + extension) stays within the filesystem limit of 255 bytes.
	// This is especially important for titles with multi-byte characters.
	outputPath := filepath.Join(cfg.App.DownloadPath, fmt.Sprintf("%s%%(title).60s.%%(ext)s", downloadProcess.ID))

	// Prepare the ytdlp command args
	args := []string{
		"-f", formatString,
		"--download-sections", fmt.Sprintf("*%s-%s", gifRequest.VideoStart, gifRequest.VideoEnd),
		"--user-agent", "random",
		"--no-playlist",
		"--no-warnings",
		"--ignore-errors",
		"--no-abort-on-error",
		"--socket-timeout", "20",
		"--retries", "3",
		"--retry-sleep", "3",
		"--force-overwrites",
		"--buffer-size", "64K",
		"-o", outputPath,
	}

	// If it's a YouTube request
	if utils.IsYouTubeURL(gifRequest.VideoURL) {
		// If we should use the YouTube cookie
		if useYoutubeCookie {
			args = append(args, "--cookies", cfg.YouTube.CookiePath)
			args = append(args, "--extractor-args", fmt.Sprintf("youtube:player-client=mweb;youtubepot-bgutilhttp:base_url=%s", cfg.YouTube.PoTokenProvider))
		} else {
			// If we should only use the Po token provider
			args = append(args, "--extractor-args", fmt.Sprintf("youtubepot-bgutilhttp:base_url=%s", cfg.YouTube.PoTokenProvider))
		}
	}

	// finally add the video url
	args = append(args, gifRequest.VideoURL)

	// Build the ytdlp command with the completed args
	ytdlpCmd = exec.Command("yt-dlp", args...)

	// Get the stderr pipe
	stderrPipe, err := ytdlpCmd.StderrPipe()
	if err != nil {
		return nil, fmt.Errorf("failed to create stderr pipe: %w", err)
	}

	// Log stderr in a separate goroutine
	go utils.LogStderr(stderrPipe, downloadProcess.ID, "ytdlp")

	// Start the ytdlp command without waiting for it to finish
	if err := ytdlpCmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start yt-dlp: %w", err)
	}

	// Return the ytdlp command.
	return ytdlpCmd, nil
}
