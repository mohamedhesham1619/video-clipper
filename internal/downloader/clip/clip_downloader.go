package clip

import (
	"bufio"
	"clipper/internal/config"
	"clipper/internal/models"
	"clipper/internal/utils"
	"fmt"
	"io"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
)

// StartClipDownload starts the video download processes and returns the running commands.
func StartClipDownload(cfg *config.Config, videoRequest models.ClipRequest, downloadProcess *models.DownloadProcess) (ytdlpCmd *exec.Cmd, err error) {

	// Create the yt-dlp commands.
	ytdlpCmd = prepareYtDlpCommand(cfg, videoRequest, downloadProcess.ID)

	// Create a pipe for yt-dlp's stderr.
	// This pipe will be used to read progress updates.
	ytdlpStderr, err := ytdlpCmd.StderrPipe()
	if err != nil {
		return nil, fmt.Errorf("error creating ytdlp stdout pipe: %v", err)
	}

	clipDurationInSeconds, err := utils.CalculateDurationSeconds(videoRequest.ClipStart, videoRequest.ClipEnd)
	if err != nil {
		return nil, err
	}

	go parseAndSendProgress(clipDurationInSeconds, ytdlpStderr, downloadProcess.ProgressChan)

	// Start both commands and do not wait for them to finish.
	if err := ytdlpCmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start yt-dlp: %w", err)
	}

	return ytdlpCmd, nil
}

func prepareYtDlpCommand(cfg *config.Config, videoRequest models.ClipRequest, processID string) *exec.Cmd {

	var formatString string

	if utils.IsYouTubeURL(videoRequest.VideoURL) {
		// Youtube often seperate the audio and video streams, so we need to prefer seperate streams to get the required video quality.
		formatString = fmt.Sprintf("bestvideo[height<=%[1]v]+bestaudio/best[height<=%[1]v]/best", videoRequest.Quality)
	} else {
		// For other sites, we can prefer the merged stream.
		formatString = fmt.Sprintf("best[height<=%[1]v]/bv*[height<=%[1]v]+ba/best/bv+ba/worst", videoRequest.Quality)
	}

	// The output file name will be in the format: <processID><title>.<ext>
	// <title> and <ext> are generated by yt-dlp.
	// Limit the video title to 60 characters to ensure the full filename (ID + title + extension) stays within the filesystem limit of 255 bytes.
	// This is especially important for titles with multi-byte characters.
	outputFile := filepath.Join(cfg.App.DownloadPath, fmt.Sprintf("%s%%(title).60s.%%(ext)s", processID))

	args := []string{
		"-f", formatString,
		"--download-sections", fmt.Sprintf("*%s-%s", videoRequest.ClipStart, videoRequest.ClipEnd),
		"--sleep-requests", "1",
		"--no-warnings",
		"--ignore-errors",
		"--no-abort-on-error",
		"--audio-quality", "0",
		"--socket-timeout", "20",
		"--retries", "3",
		"--retry-sleep", "3",
		"--force-overwrites",
		"--concurrent-fragments", "3",
		"--buffer-size", "64K",
		"--newline",
		"-o", outputFile,
	}

	if utils.IsYouTubeURL(videoRequest.VideoURL) {
		args = append(args, "--cookies", cfg.YouTube.CookiePath)
		args = append(args, "--extractor-args", "youtube:player_client=mweb")

	}
	args = append(args, videoRequest.VideoURL)
	return exec.Command("yt-dlp", args...)
}

func parseAndSendProgress(clipDuration int, pipe io.ReadCloser, progressChan chan models.ProgressEvent) {
	reader := bufio.NewReader(pipe)
	var line string
	
	// Regex to match ffmpeg time output: time=00:00:05.84
	re := regexp.MustCompile(`time=(\d{2}):(\d{2}):(\d{2})`)

	buf := make([]byte, 1)
	for {
		n, err := reader.Read(buf)
		if n > 0 {
			char := buf[0]
			
			// If carriage return or newline, process the line
			if char == '\r' || char == '\n' {
				if len(line) > 0 {
					match := re.FindStringSubmatch(line)
					if len(match) == 4 {
						hours, _ := strconv.Atoi(match[1])
						minutes, _ := strconv.Atoi(match[2])
						seconds, _ := strconv.Atoi(match[3])

						processedTime := hours*3600 + minutes*60 + seconds
						percentage := (processedTime * 100) / clipDuration

						if percentage >= 100 {
							percentage = 100
						}

						progressChan <- models.ProgressEvent{
							Event: models.EventTypeProgress,
							Data:  map[string]string{"progress": fmt.Sprintf("%d", percentage)},
						}
					}
					line = "" // Reset line
				}
			} else {
				line += string(char)
			}
		}
		
		if err != nil {
			break
		}
	}
}
