package clip

import (
	"bufio"
	"clipper/internal/config"
	"clipper/internal/cookie"
	"clipper/internal/models"
	"clipper/internal/utils"
	"fmt"
	"io"
	"log/slog"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

// StartClipDownload starts the video download processes and returns the running commands.
func StartClipDownload(cfg *config.Config, videoRequest models.ClipRequest, downloadProcess *models.DownloadProcess, useYoutubeCookie bool) (ytdlpCmd *exec.Cmd, err error) {

	// Create the yt-dlp commands.
	ytdlpCmd = prepareYtDlpCommand(cfg, videoRequest, downloadProcess.ID, useYoutubeCookie)

	// Create a pipe for yt-dlp's stderr.
	// This pipe will be used to read progress updates and log errors.
	ytdlpStderr, err := ytdlpCmd.StderrPipe()
	if err != nil {
		return nil, fmt.Errorf("error creating ytdlp stderr pipe: %v", err)
	}

	clipDurationInSeconds, err := utils.CalculateDurationSeconds(videoRequest.ClipStart, videoRequest.ClipEnd)
	if err != nil {
		return nil, err
	}

	// Parse progress and log stderr in one goroutine
	go parseAndSendProgress(clipDurationInSeconds, ytdlpStderr, downloadProcess.ProgressChan)

	// Start the command
	if err := ytdlpCmd.Start(); err != nil {
		return nil, fmt.Errorf("failed to start yt-dlp: %w", err)
	}

	return ytdlpCmd, nil
}

func prepareYtDlpCommand(cfg *config.Config, videoRequest models.ClipRequest, processID string, useYoutubeCookie bool) *exec.Cmd {

	var formatString string

	if utils.IsYouTubeURL(videoRequest.VideoURL) {
		// Youtube often seperate the audio and video streams, so we need to prefer seperate streams to get the required video quality.

		// Prefer HLS streams first (much faster, not throttled), then fall back to regular streams
		formatString = fmt.Sprintf("bestvideo[height<=%[1]v][protocol^=m3u8]+bestaudio[protocol^=m3u8]/best[height<=%[1]v][protocol^=m3u8]/bestvideo[height<=%[1]v]+bestaudio/best[height<=%[1]v]/best", videoRequest.Quality)

	} else {
		// For other sites, we can prefer the merged stream.
		formatString = fmt.Sprintf("best[height<=%[1]v]/bv*[height<=%[1]v]+ba/best/bv+ba/worst", videoRequest.Quality)
	}

	// The output file name will be in the format: <processID><title>_<resolution>p.<ext>
	// <title>, <height>, and <ext> are generated by yt-dlp using template variables.
	// Limit the video title to 50 characters to ensure the full filename (ID + title + resolution + extension) stays within the filesystem limit of 255 bytes.
	// This is especially important for titles with multi-byte characters.
	outputFile := filepath.Join(cfg.App.DownloadPath, fmt.Sprintf("%s%%(title).50s_%%(height)sp.%%(ext)s", processID))

	args := []string{
		"-f", formatString,
		"--download-sections", fmt.Sprintf("*%s-%s", videoRequest.ClipStart, videoRequest.ClipEnd),
		"--user-agent", "random",
		"--no-playlist",
		"--no-warnings",
		"--ignore-errors",
		"--no-abort-on-error",
		"--audio-quality", "0",
		"--socket-timeout", "20",
		"--retries", "3",
		"--retry-sleep", "3",
		"--force-overwrites",
		"--concurrent-fragments", "3",
		"--buffer-size", "64K",
		"--newline",
		"-o", outputFile,
	}

	// If it's a YouTube request
	if utils.IsYouTubeURL(videoRequest.VideoURL) {
		// If we should use the YouTube cookie
		if useYoutubeCookie {
			cookie := cookie.YouTube()
			slog.Info("Using YouTube cookie", "cookie", filepath.Base(cookie), "process ID", processID)
			args = append(args, "--cookies", cookie)
			args = append(args, "--extractor-args", fmt.Sprintf("youtubepot-bgutilhttp:base_url=%s", cfg.YouTube.PoTokenProvider))
		} else {
			// If we should only use the Po token provider
			args = append(args, "--extractor-args", fmt.Sprintf("youtubepot-bgutilhttp:base_url=%s", cfg.YouTube.PoTokenProvider))
		}
	}

	args = append(args, videoRequest.VideoURL)
	return exec.Command("yt-dlp", args...)
}

func parseAndSendProgress(clipDuration int, pipe io.ReadCloser, progressChan chan models.ProgressEvent) {

	// We need to read byte by byte because yt-dlp (and ffmpeg) often use \r to update progress inline.
	reader := bufio.NewReader(pipe)
	var line []byte

	// Regex to match ffmpeg time output: time=00:00:05.84
	re := regexp.MustCompile(`time=(\d{2}):(\d{2}):(\d{2})`)

	for {
		// Read one byte at a time
		b, err := reader.ReadByte()
		if err != nil {
			if err != io.EOF {
				slog.Error("Error reading pipe", "error", err)
			}
			break
		}

		// If we hit a delimiter, process the accumulated line
		if b == '\r' || b == '\n' {
			if len(line) > 0 {
				lineStr := string(line)
				if strings.Contains(lineStr, "ERROR") {
					slog.Error("yt-dlp output", "line", lineStr)
					line = nil // Reset line buffer
					continue
				}

				match := re.FindStringSubmatch(lineStr)
				if len(match) == 4 {
					hours, _ := strconv.Atoi(match[1])
					minutes, _ := strconv.Atoi(match[2])
					seconds, _ := strconv.Atoi(match[3])

					processedTime := hours*3600 + minutes*60 + seconds
					percentage := (processedTime * 100) / clipDuration

					if percentage >= 100 {
						percentage = 100
					}

					progressChan <- models.ProgressEvent{
						Event: models.EventTypeProgress,
						Data:  map[string]string{"progress": fmt.Sprintf("%d", percentage)},
					}
				}
				line = nil // Reset line buffer
			}
		} else {
			line = append(line, b)
		}
	}
}
